import re
import logging
from typing import Dict, List, Optional, Any
from music_theory import MusicTheoryTeacher

logger = logging.getLogger(__name__)

class ChatProcessor:
    """Processador de mensagens do chat musical."""
    
    def __init__(self, theory_teacher: MusicTheoryTeacher):
        self.theory_teacher = theory_teacher
        self.setup_patterns()
    
    def setup_patterns(self):
        """Define os padr√µes regex para reconhecimento de perguntas."""
        self.patterns = {
            'campo_harmonico': re.compile(
                r'campo harm[o√¥]nico.*?(?:de\s+)?([a-g]#?)\s*(maior|menor)?',
                re.IGNORECASE
            ),
            'escala': re.compile(
                r'escala.*?(?:de\s+)?([a-g]#?)\s*(maior|menor)?',
                re.IGNORECASE
            ),
            'acorde': re.compile(
                r'(?:acorde\s+)?([a-g]#?)\s*(maior|menor|m|7|maj7|dim|aug)?',
                re.IGNORECASE
            ),
            'intervalo': re.compile(
                r'intervalo.*?entre\s+([a-g]#?)\s+e\s+([a-g]#?)',
                re.IGNORECASE
            ),
            'modo': re.compile(
                r'(?:modo\s+)?([a-g]#?)\s*(j[o√¥]nio|d[o√≥]rico|fr[i√≠]gio|l[i√≠]dio|mixol[i√≠]dio|e[o√≥]lio|l[o√≥]crio)',
                re.IGNORECASE
            ),
            'formacao_acorde': re.compile(
                r'(?:como\s+formar|forma[√ßc][a√£]o.*?do?)\s+(?:acorde\s+)?([a-g]#?)\s*(maior|menor|m|7)?',
                re.IGNORECASE
            )
        }
    
    def process_message(self, message: str) -> str:
        """Processa uma mensagem e retorna a resposta."""
        try:
            message = message.strip()
            logger.info(f"Processando mensagem: {message}")
            
            # Normaliza a mensagem
            normalized_message = self.normalize_message(message)
            
            # Tenta identificar o tipo de pergunta e processar
            response = self.identify_and_process(normalized_message)
            
            if response:
                return response
            
            # Se n√£o reconheceu nenhum padr√£o, retorna mensagem padr√£o
            return self.get_default_response()
            
        except Exception as e:
            logger.error(f"Erro ao processar mensagem: {str(e)}")
            return "Desculpe, ocorreu um erro ao processar sua pergunta. Tente novamente."
    
    def normalize_message(self, message: str) -> str:
        """Normaliza a mensagem para melhor processamento."""
        # Remove acentos e caracteres especiais desnecess√°rios
        replacements = {
            '√°': 'a', '√†': 'a', '√£': 'a', '√¢': 'a',
            '√©': 'e', '√™': 'e',
            '√≠': 'i', '√Æ': 'i',
            '√≥': 'o', '√¥': 'o', '√µ': 'o',
            '√∫': 'u', '√ª': 'u',
            '√ß': 'c'
        }
        
        normalized = message.lower()
        for old, new in replacements.items():
            normalized = normalized.replace(old, new)
        
        return normalized
    
    def identify_and_process(self, message: str) -> Optional[str]:
        """Identifica o tipo de pergunta e processa adequadamente."""
        
        # Campo harm√¥nico
        if 'campo harmonico' in message or 'campo harm√¥nico' in message:
            return self.process_harmonic_field_question(message)
        
        # Escala
        if 'escala' in message:
            return self.process_scale_question(message)
        
        # Forma√ß√£o de acorde
        if any(phrase in message for phrase in ['como formar', 'formacao', 'forma√ß√£o']):
            return self.process_chord_formation_question(message)
        
        # Acorde espec√≠fico
        if 'acorde' in message or self.is_chord_query(message):
            return self.process_chord_question(message)
        
        # Intervalo
        if 'intervalo' in message and 'entre' in message:
            return self.process_interval_question(message)
        
        # Modo
        if self.is_mode_query(message):
            return self.process_mode_question(message)
        
        # Perguntas gerais
        if 'circulo' in message or 'c√≠rculo' in message or 'ciclo' in message:
            return self.get_circle_of_fifths_info()
        
        if 'exercicio' in message or 'exerc√≠cio' in message:
            return self.get_exercise_info()
        
        return None
    
    def process_harmonic_field_question(self, message: str) -> str:
        """Processa perguntas sobre campo harm√¥nico."""
        match = self.patterns['campo_harmonico'].search(message)
        
        if not match:
            return "Especifique a tonalidade. Exemplo: 'campo harm√¥nico de C maior'"
        
        tonica = match.group(1).upper()
        modo = match.group(2) or 'maior'  # Padr√£o √© maior
        
        mode_eng = 'minor' if 'menor' in modo.lower() else 'major'
        resultado = self.theory_teacher.explain_harmonic_field(tonica, mode_eng)
        
        if "erro" in resultado:
            return f"‚ùå {resultado['erro']}"
        
        # Formata a resposta
        acordes_info = []
        for acorde in resultado["acordes"]:
            acordes_info.append(f"<strong>{acorde['grau']}</strong> - {acorde['cifra']} ({acorde['funcao']})")
        
        progressoes = "<br>".join(resultado["progressoes_comuns"])
        
        return f"""
        <strong>üéº Campo harm√¥nico de {resultado['tonalidade']}:</strong><br><br>
        {' <br>'.join(acordes_info)}<br><br>
        <strong>üìù Progress√µes comuns:</strong><br>
        {progressoes}
        """
    
    def process_scale_question(self, message: str) -> str:
        """Processa perguntas sobre escalas."""
        match = self.patterns['escala'].search(message)
        
        if not match:
            return "Especifique a escala. Exemplo: 'escala de D maior'"
        
        tonica = match.group(1).upper()
        modo = match.group(2) or 'maior'
        
        scale_type = 'minor' if 'menor' in modo.lower() else 'major'
        resultado = self.theory_teacher.explain_scale(tonica, scale_type)
        
        if "erro" in resultado:
            return f"‚ùå {resultado['erro']}"
        
        return f"""
        <strong>üéµ Escala de {resultado['escala']}:</strong><br>
        <strong>Notas:</strong> {' - '.join(resultado['notas'])}<br>
        <strong>Padr√£o:</strong> {resultado['padrao']} (T=Tom, S=Semitom)<br>
        <strong>Descri√ß√£o:</strong> {resultado['descricao']}
        """
    
    def process_chord_formation_question(self, message: str) -> str:
        """Processa perguntas sobre forma√ß√£o de acordes."""
        match = self.patterns['formacao_acorde'].search(message)
        
        if not match:
            return """
            <strong>üé∏ Forma√ß√£o de Acordes B√°sicos:</strong><br><br>
            ‚Ä¢ <strong>Acorde Maior:</strong> 1¬™ + 3¬™ maior + 5¬™ justa<br>
            ‚Ä¢ <strong>Acorde Menor:</strong> 1¬™ + 3¬™ menor + 5¬™ justa<br>
            ‚Ä¢ <strong>Acorde de 7¬™:</strong> Tr√≠ade + 7¬™ menor<br><br>
            Exemplo: "como formar acorde C maior"
            """
        
        root = match.group(1).upper()
        chord_type = match.group(2) or 'maior'
        
        # Converte para formato do theory_teacher
        if chord_type.lower() in ['menor', 'm']:
            chord_type_eng = 'minor'
        elif chord_type == '7':
            chord_type_eng = '7'
        else:
            chord_type_eng = 'major'
        
        resultado = self.theory_teacher.explain_chord(root, chord_type_eng)
        
        if "erro" in resultado:
            return f"‚ùå {resultado['erro']}"
        
        return f"""
        <strong>üé∏ Acorde {resultado['acorde']}:</strong><br>
        <strong>Notas:</strong> {' - '.join(resultado['notas'])}<br>
        <strong>Intervalos:</strong> {', '.join(resultado['intervalos'])}<br>
        <strong>Descri√ß√£o:</strong> {resultado['descricao']}<br>
        <strong>Cifra:</strong> {resultado['cifra']}
        """
    
    def process_chord_question(self, message: str) -> str:
        """Processa perguntas sobre acordes espec√≠ficos."""
        match = self.patterns['acorde'].search(message)
        
        if not match:
            return "Especifique o acorde. Exemplo: 'acorde C maior' ou 'G7'"
        
        root = match.group(1).upper()
        chord_type = match.group(2) or 'maior'
        
        # Mapeamento de tipos de acorde
        type_mapping = {
            'maior': 'major',
            'menor': 'minor',
            'm': 'minor',
            '7': '7',
            'maj7': 'maj7',
            'dim': 'dim',
            'aug': 'aug'
        }
        
        chord_type_eng = type_mapping.get(chord_type.lower(), 'major')
        resultado = self.theory_teacher.explain_chord(root, chord_type_eng)
        
        if "erro" in resultado:
            return f"‚ùå {resultado['erro']}"
        
        return f"""
        <strong>üé∏ Acorde {resultado['acorde']}:</strong><br>
        <strong>Notas:</strong> {' - '.join(resultado['notas'])}<br>
        <strong>Intervalos:</strong> {', '.join(resultado['intervalos'])}<br>
        <strong>Descri√ß√£o:</strong> {resultado['descricao']}
        """
    
    def process_interval_question(self, message: str) -> str:
        """Processa perguntas sobre intervalos."""
        match = self.patterns['intervalo'].search(message)
        
        if not match:
            return "Especifique as duas notas. Exemplo: 'intervalo entre C e E'"
        
        nota1 = match.group(1).upper()
        nota2 = match.group(2).upper()
        
        resultado = self.theory_teacher.explain_interval(nota1, nota2)
        
        if "erro" in resultado:
            return f"‚ùå {resultado['erro']}"
        
        return f"""
        <strong>üéº Intervalo entre {resultado['nota1']} e {resultado['nota2']}:</strong><br>
        <strong>Intervalo:</strong> {resultado['intervalo']} ({resultado['semitons']} semitons)<br>
        <strong>Descri√ß√£o:</strong> {resultado['descricao']}<br>
        {f"<strong>Exemplo:</strong> {resultado['exemplo_musical']}" if 'exemplo_musical' in resultado else ""}
        """
    
    def process_mode_question(self, message: str) -> str:
        """Processa perguntas sobre modos."""
        match = self.patterns['modo'].search(message)
        
        if not match:
            return """
            <strong>üéº Modos Gregos:</strong><br>
            J√¥nio, D√≥rico, Fr√≠gio, L√≠dio, Mixol√≠dio, E√≥lio, L√≥crio<br><br>
            Exemplo: "modo C j√¥nio" ou "D d√≥rico"
            """
        
        tonica = match.group(1).upper()
        modo = match.group(2).lower()
        
        # Normaliza o nome do modo
        modo_mapping = {
            'jonio': 'j√¥nio',
            'dorico': 'd√≥rico',
            'frigio': 'fr√≠gio',
            'lidio': 'l√≠dio',
            'mixolidio': 'mixol√≠dio',
            'eolio': 'e√≥lio',
            'locrio': 'l√≥crio'
        }
        
        modo_normalizado = modo_mapping.get(modo, modo)
        resultado = self.theory_teacher.explain_mode(tonica, modo_normalizado)
        
        if "erro" in resultado:
            return f"‚ùå {resultado['erro']}"
        
        return f"""
        <strong>üéº Modo {resultado['modo']}:</strong><br>
        <strong>Notas:</strong> {' - '.join(resultado['notas'])}<br>
        <strong>Descri√ß√£o:</strong> {resultado['descricao']}<br>
        {f"<strong>Caracter√≠sticas:</strong> {resultado['caracteristica']}" if 'caracteristica' in resultado else ""}
        {f"<br><strong>G√™neros:</strong> {', '.join(resultado['generos_musicais'])}" if 'generos_musicais' in resultado else ""}
        """
    
    def is_chord_query(self, message: str) -> bool:
        """Verifica se a mensagem √© uma consulta sobre acorde."""
        # Padr√µes simples como "C", "Am", "G7"
        simple_chord_pattern = re.compile(r'^[a-g]#?(?:m|maj|dim|aug|7|maj7|m7|dim7)?$', re.IGNORECASE)
        return bool(simple_chord_pattern.match(message.strip()))
    
    def is_mode_query(self, message: str) -> bool:
        """Verifica se a mensagem √© sobre modos."""
        modos = ['jonio', 'j√¥nio', 'dorico', 'd√≥rico', 'frigio', 'fr√≠gio', 
                'lidio', 'l√≠dio', 'mixolidio', 'mixol√≠dio', 'eolio', 'e√≥lio', 
                'locrio', 'l√≥crio']
        
        return any(modo in message.lower() for modo in modos)
    
    def get_circle_of_fifths_info(self) -> str:
        """Retorna informa√ß√µes sobre o c√≠rculo das quintas."""
        return """
        <strong>üîÑ C√≠rculo das Quintas:</strong><br><br>
        <strong>Sentido hor√°rio (sustenidos):</strong><br>
        C ‚Üí G ‚Üí D ‚Üí A ‚Üí E ‚Üí B ‚Üí F# ‚Üí C#<br><br>
        <strong>Sentido anti-hor√°rio (bem√≥is):</strong><br>
        C ‚Üí F ‚Üí Bb ‚Üí Eb ‚Üí Ab ‚Üí Db ‚Üí Gb ‚Üí Cb<br><br>
        <strong>üí° Dica:</strong> √â uma ferramenta fundamental para entender rela√ß√µes entre tonalidades e progress√µes harm√¥nicas. 
        Cada movimento no sentido hor√°rio adiciona um sustenido, no anti-hor√°rio adiciona um bemol.
        """
    
    def get_exercise_info(self) -> str:
        """Retorna informa√ß√µes sobre exerc√≠cios."""
        return """
        <strong>üéØ Exerc√≠cios Dispon√≠veis:</strong><br><br>
        Use os bot√µes na se√ß√£o "Exerc√≠cios Musicais" para gerar:<br><br>
        ‚Ä¢ <strong>üéº Intervalos</strong> - Identifica√ß√£o de intervalos entre notas<br>
        ‚Ä¢ <strong>üé∏ Acordes</strong> - Forma√ß√£o e an√°lise de acordes<br>
        ‚Ä¢ <strong>üéµ Escalas</strong> - Constru√ß√£o de escalas musicais<br><br>
        Os exerc√≠cios s√£o gerados automaticamente e ajudam voc√™ a praticar e fixar o conhecimento! üìö
        """
    
    def get_default_response(self) -> str:
        """Retorna resposta padr√£o quando n√£o reconhece a pergunta."""
        return """
        Ainda n√£o sei responder essa pergunta espec√≠fica, mas estou aprendendo! üéµ<br><br>
        <strong>üìö Posso ajudar com:</strong><br>
        ‚Ä¢ <strong>Escalas:</strong> "escala de D maior"<br>
        ‚Ä¢ <strong>Acordes:</strong> "acorde G7" ou "como formar C menor"<br>
        ‚Ä¢ <strong>Campo harm√¥nico:</strong> "campo harm√¥nico de A menor"<br>
        ‚Ä¢ <strong>Intervalos:</strong> "intervalo entre F e A"<br>
        ‚Ä¢ <strong>Modos:</strong> "modo C mixol√≠dio"<br>
        ‚Ä¢ <strong>Teoria geral:</strong> "c√≠rculo das quintas"<br><br>
        <strong>üéØ Tamb√©m posso gerar exerc√≠cios para voc√™ praticar!</strong><br>
        Use os bot√µes na se√ß√£o de exerc√≠cios ou envie um arquivo de √°udio para an√°lise.
        """
    
    def extract_note_from_text(self, text: str) -> Optional[str]:
        """Extrai uma nota musical do texto."""
        note_pattern = re.compile(r'\b([a-g]#?)\b', re.IGNORECASE)
        match = note_pattern.search(text)
        return match.group(1).upper() if match else None
    
    def extract_notes_from_text(self, text: str) -> List[str]:
        """Extrai m√∫ltiplas notas musicais do texto."""
        note_pattern = re.compile(r'\b([a-g]#?)\b', re.IGNORECASE)
        matches = note_pattern.findall(text)
        return [note.upper() for note in matches]
    
    def validate_note(self, note: str) -> bool:
        """Valida se a nota est√° no formato correto."""
        return note.upper() in self.theory_teacher.note_names